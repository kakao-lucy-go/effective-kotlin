# 아이템 41. hashCode의 규약을 지켜라

hashCode는 해시 테이블을 구축할 때 사용한다.

## 해시 테이블

Set 과 Map은 중복을 허용하지 않기 때문에, 요소를 추가할 땐 동일한 요소가 있는지 확인한다. 리스트나 배열은 모든 요소와 비교해서 성능이 좋지 않지만, 해시 테이블은 각 요소에 숫자를 할당하는 함수(해시 함수)가 필요하고, 같은 요소만 항상 같은 숫자를 리턴한다.

해시함수의 특성

- 빠르다
- 충돌이 적다. 다른 값이면 최대한 다른 숫자가 나온다.

해시 함수는 특정한 숫자를 할당하고 버킷에 넣는다. 같은 요소는 동일한 버킷에 넣고, 버킷은 버킷 수와 같은 크기의 배열인 해시 테이블에 보관한다.

해시 함수는 빠르게 같은 요소인지 찾아서 같으면 같은 값을 리턴한다. 버킷을 특정한 후 버킷 내부에 원하는 요소를 찾기 때문에 버킷을 특정하고 나서의 요소 수만큼의 비교만 일어나서 빠르다.

이는 디비, 인터넷 프로토콜, 표준 라이브러리 컬렉션, LinkedHashSet, LinkedHashMap에서 사용하고, 해시 코드를 만들 때 코틀린에서는 hashCode를 사용한다.

## 가변성과 관련된 문제

요소가 추가될 때만 hashCode를 계산한다. 요소가 변경되어도 hashCode는 계산되지 않고 버킷 재배치도 일어나지 않는다.

해시 등의 ‘mutable 프로퍼티로 요소를 조합하는 자료 구조'에서는 mutable 객체가 사용되지 않는다. 따라서 set, map의 키로 mutable 을 사용하면 안되고, 사용해도 변경하면 안된다. 따라서 immutable 객체를 사용한다.

## hashCode의 규약

1. 일관성: 어떤 객체를 변경하지 않았다면 hashCode를 여러 번 호출해도 항상 같은 값이 나온다.
2. equals에서 두 객체가 같다고 나온다면 hashCode의 결과도 같다. - 컬렉션 내부 요소의 값을 확인한다.

그래서 equals를 구현할 때 hashCode도 함께 구현하는 것을 추천한다. 

hashCode는 다른 요소는 최대한 다른 해시 값을 갖는다. 같은 값이 나오면 하나의 버킷에만 몰릴 수 있다. 

## hashCode 구현하기

data 클래스로 만들면 알아서 적절하게 구현해준다. 

직접 구현할 땐 보통 equals 비교에 사용되는 프로퍼티를 기반으로 모든 해시 코드의 값을 더한다. 더하는 과정마다 이전까지의 결과에 31을 곱한 뒤 더해준다. 관례적으로 31을 곱하는 것이다.

```kotlin
override fun hashCode(): Int {
	var result = millis.hashCode()
	result = result * 31 + timeZone.hashCode()
	return result
}
```

코틀린/JVM 에서 Objects.hashCode 는 해시를 계산해준다. 

코틀린 stdlib에는 따로 없다.
