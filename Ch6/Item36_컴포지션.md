# 아이템 36. 상속보다는 컴포지션을 사용하라

단순하게 코드 추출 또는 재사용을 하려고 한다면 상속보다 컴포지션이 좋다.

### 5.36.1 간단한 행위 재사용

단순히 추출을 위해 상속을 사용하면 다음과 같은 단점이 있다.

1. 상속은 하나의 클래스만 가능해서 추출하다보면 거대한 클래스가 되며 깊고 복잡한 계층구조가 만들어진다.
2. 상속하는 클래스의 모든 것을 가져오게 돼서 불필요한 것도 가져와진다. - 인터페이스 분리 원칙 위반 
3. 상속은 가독성이 좋지 않다.

이때 컴포지션을 사용한다. 객체를 프로퍼티로 갖고 함수를 호출하는 형태로 재사용하는 것을 의미한다.

컴포지션을 활용하면 하나의 클래스에서 여러 기능을 재사용할 수 있다.

### 5.26.2 모든 것을 가져올 수 밖에 없는 상속

상속하는 클래스의 모든 것을 가져오기 때문에 인터페이스 분리 원칙 외에도 리스코프 치환 원칙(슈퍼클래스의 동작을 서브클래스에서 변경한다.)도 위반한다.

물론 계층 구조를 표현해야 한다면 상속이 좋다.

### 5.36.3 캡슐화를 깨는 상속

내부적인 구현 방법에 의해 캡슐화가 깨질 수 있다. 상속하는 클래스의 구현 방법이 달라져서 더이상 구현한 기능을 쓰지 않으면 문제가 발생한다.

Q. 예제에서.. 6이 나온다고 했는데 재귀가 발생할 것 처럼 생겼다.

이 때 컴포지션을 사용하면 이 문제를 해결할 수 있지만 다형성이 사라진다.

다형성: 한 객체가 여러 타입을 가질 수 있다.

이런 경우엔 위임 패턴을 사용해서, 클래스가 인터페이스를 상속받고 메소드를 구현(포워딩 메소드)하면 다형성의 성질을 다시 가질 수 있다.

다형성이 필요하지 않은 경우엔 컴포지션이 유용하다. 

### 5.36.4 오버라이딩 제한하기

final 을 사용해서 상속을 막을 수 있다.

상속은 허용하지만 메소드는 오버라이드 못하게 하려면 open 키워드를 사용한다.

### 5.36.5 정리

- 컴포지션이 더 안전하다. 내부 구현에 의존하지 않기 때문이다.
- 컴포지션이 더 유연하다. 상속은 하나만 되는데, 컴포지션은 여러 클래스를 대상으로 할 수 있기 때문이다.
- 컴포지션이 더 명시적이다. 슈퍼클래스의 메소드를 사용할 때는 리시버를 따로 지정하지 않아도 되지만 이는 덜 명시적이다. 컴포지션은 리시버를 명시적으로 활용할 수 밖에 없어서 메소드가 어디있는지 확실하게 알 수 있다.
- 컴포지션은 생각보다 번거롭다.
- 상속은 다형성을 활용할 수 있다.

일반적으로 상속보다는 컴포지션이 좋다.

상속은 명확한 is-a 관계일 때 사용하는 것이 좋다. 리스코프 치환 원칙으로, 슈퍼 클래스의 테스트는 서브 클래스의 테스트에도 통과해야 한다.
