# 아이템 49. 하나 이상의 처리 단계를 가진 경우에는 시퀀스를 사용하라

Iterable과 Sequence는 정의가 동일하지만 목적이 달라 완전히 다른 형태로 동작한다.

Sequence는 지연 처리 되기 때문에 데코레이터 패턴으로 꾸며진 새로운 시퀀스가 리턴된다. 최종 계산은 toList나 count등에 의해 수행된다.

반면 Iterable은 처리 함수가 사용될 때마다 List가 만들어진다.

**Sequence의 지연 처리 장점**

1. 처리 순서가 자연스럽다.
2. 최소한의 연산만 한다. ← 이게 제일 큰 장점같음 
3. 무한 시퀀스 형태로 사용할 수 있다.
4. 각각의 단계에서 컬렉션을 만들지 않는다. ← 이것두 

## 순서의 중요성

시퀀스 처리는 요소 하나하나에 연산을 한꺼번에 적용한다. 이를 element-by-element order, lazy order라고 한다.

이터러블은 요소 전체를 대상으로 연산을 차근차근 적용해나간다. 이를 step-by-step order, eager order라고 한다.

시퀀스 처리는 기본적인 반복문과 조건문을 사용하는 코드와 같다.

## 최소 연산

어떤 처리를 하고 앞의 요소 10개만 필요한데 중간 연산을 모든 요소에 적용할 필요가 없는 경우에는 시퀀스를 사용하는 것이 좋다. 요소를 선택하는 연산은 first, take, any, all, none, indexOf가 있다.

## 무한 시퀀스

무한 시퀀스를 만들고 필요한 부분 까지만 값을 추출할 수도 있다. 

무한 시퀀스는 generateSequence, sequence를 사용해서 만들 수 있다. 

- generateSequence: 첫 번쨰 요소와 그 다음 요소를 계산하는 방법을 지정
- sequence: 중단 함수(코루틴)로 요소들을 지정하고, 내부에서 yield로 값을 만들어낸다.

단, 무한 시퀀스는 값을 몇 개 사용할 것인지 take등으로 지정해주지 않으면 무한히 반복한다. 따라서 종결 연산으로 take, first정도만 사용하는 것이 좋다.

## 각각의 단계에서 컬렉션을 만들지 않음

각각의 단계에서 컬렉션이 만들어지면 비용이 든다. 시퀀스를 사용하면 이 낭비를 줄일 수 있다. 

## 시퀀스가 빠르지 않은 경우

컬렉션 전체를 기반으로 처리해야하는 경우에는 빨라지지 않는다. 유일한 예로 코틀린 stdlib의 sorted가 있다. 이는 시퀀스를 List로 변환한 뒤 자바의 sort를 사용해서 처리하는데 변환처리로 인해 더 느려진다. 

그래서 시퀀스에서 sorted를 빼야한다는 의견도 있지만 일반적으로 사용하기 때문에 포함이 되었다. 하지만 문제는 인지해야 한다.

## 자바 스트림의 경우

자바 8부터 컬렉션 처리에 스트림 기능이 추가되었다. 이도 lazy하게 동작한다.

**자바 스트림과 코틀린 시퀀스의 차이점**

1. 코틀린의 시퀀스가 더 많은 처리 함수를 가진다.
2. 자바 스트림은 병렬 함수로 멀티 코어 환경에서 큰 성능 향상을 가져오지만 몇 가지 결함이 있다.
3. 코틀린의 시퀀스는 일반적인 모듈에서 다 동작하지만 자바 스트림은 자바 8 이상 코틀린/JVM에서만 동작한다.

병렬 모드를 사용하지 않는다면 둘 중 무엇이 더 효율적인지 판단할 수 없다.

## 코틀린 시퀀스 디버깅

코틀린은 Kotlin Sequence Debugger라는 플러그인으로 스트림을 디버깅할 수 있고, Kotlin 플러그인에 통합되어 있다.

## 정리

시퀀스는 변환 작업이 필요하고 최종 결과를 다시 컬렉션으로 변환하는 작업도 필요하지만 lazy하게 처리함으로서 최소한의 연산, 무한 시퀀스 사용 가능, 각 단계에서 컬렉션을 만들지 않는다는 장점이 있다. 

따라서 무거운 객체나 규모가 큰 컬렉션을 사용할 땐 시퀀스를 쓰는 것이 더 좋다.
