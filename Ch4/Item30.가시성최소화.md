# 아이템30. 요소의 가시성을 최소화하라

API를 설계할 땐 가능한 한 간결하게 한다.

1. 작은 인터페이스는 배우기 쉽고 유지보수하기 쉽다.
2. 변경을 가할 땐 기존의 것을 숨기는 것 보다 새로운 것을 노출하는게 쉽다. 기존 것은 이미 사용 중이기 때문에 모든 곳에서 영향을 받기 때문이다. 특히 가시성 제한은 더 신중해야 한다.
3. 클래스의 상태를 저장하는 프로퍼티를 외부에서 변경할 수 있다면 클래스는 자신의 상태를 보장할 수 없기 때문에 클래스의 불변성이 무너질 수 있다. 그래서 세터를 private으로 만든 코드는 굉장히 많다. 이런 식으로 모든 프로퍼티를 캡슐화하는 것이 좋다. 또, 동시성 문제에서 안전해진다.

### 4.30.1. 가시성 한정자 사용하기

클래스 멤버라면 다음과 같은 4개의 가시성 한정자를 사용할 수 있다.

1. public(디폴트): 어디서나 볼 수 있다.
2. private: 클래스 내부에서만 볼 수 있다. 동일한 파일 내부에서만 사용하게 만든다.
3. protected: 클래스와 서브클래스 내부에서만 볼 수 있다. 상속을 위해 설계되어 있고, 클래스와 서브클래스에서만 사용되게 만들고 싶을 때 사용한다.
4. internal: 모듈 내부에서만 볼 수 있다. 모듈이 다른 모듈에 의해 사용될 가능성이 있다면 공개하고 싶지 않은 요소를 숨길 수 있다.

톱레벨은 3개의 한정자를 사용할 수 있다.

1. public(디폴트): 어디서나 볼 수 있다.
2. private: 같은 파일 내부에서만 볼 수 있다.
3. internal: 모듈 내부에서만 볼 수 있다.

```
모듈과 패키지.
모듈 : 코틀린에서 모듈은 함께 컴파일되는 코틀린 소스. 
* 그레이들 소스 세트
* 메이븐 프로젝트 
* 인텔리제이 IDEA 모듈
* 앤트 태스크 한 번으로 컴파일되는 파일 세트
```

참고로, 지역적으로만 사용되는 프로퍼티는 private으로 만드는게 좋다고 힌트를 주지만 데이터 모델 클래스(DTO)의 경우에는 적용되지 않는게 좋다. 숨길 이유가 없기 때문이다. 

API를 상속할 때 오버라이드해서 가시성을 제한할 수 없다.

(서브클래스가 슈퍼클래스로도 사용될 수 있기 때문이다. 이는 상속보다 컴포지션을 선호하는 대표적인 이유이다. 아이템 36)) - 상속하지 말고 프로퍼티로 갖고 있어라
