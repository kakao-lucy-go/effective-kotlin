# 아이템27. 변화로부터 코드를 보호하려면 추상화를 사용하라

함수와 클래스 등의 추상화로 실질적인 코드를 숨기면 사용자가 세부 사항을 알지 못해도 괜찮고, 이후에 실질적인 코드를 수정하기에도 용이하다.

다음은 추상화로 코드를 숨겨서 얻는 이점의 세 가지 실제 사례에 대해 알아본다.

### 4.27.1 상수

문자열을 상수 프로퍼티로 변경해 해당 값에 의미있는 이름을 부여해서 상수 값을 변경할 때 쉽게 할 수 있다.

아래 예제에서 7 자체는 의미가 없지만 로직 상 ‘비밀번호의 최소 길이'를 의미하고, 상수로 빼내면 이해하기 훨씬 쉽고 수정이 용이하다.

```kotlin
fun isPasswordValid(text: String): Boolean {
	if(text.length < 7) return false
}
```

### 4.27.2 함수

많이 사용되는 알고리즘은 간단한 확장 함수로 사용해서 추출하면 코드를 항상 기억하지 않아도 되고 로직이 변경되어도 확장 함수 부분만 수정하면 돼서 유지보수성이 좋아진다.

다만, 함수의 이름이나 파라미터를 직접 바꾸면 사용하는 모든 곳에서 문제가 있을 수 있기 때문에 ‘의도'에 초점을 맞춰서 세부 함수와 무관한 좀 더 넓은 범위의 함수를 만들어서 사람의 입장에서 이해하기 좋게 만든다.

### 4.27.3 클래스

클래스는 함수와 달리 상태를 가질 수 있고 많은 함수를 가질 수 있다는 특징(클래스의 함수는 메소드라 한다.)이 있다. 

의존성 주입 프레임워크로 의존성을 주입할 수 있고, 더 다양한 종류의 메소드를 만들어 사용할 수 있다.

클래스가 함수보다 자유롭긴 하지만 한계가 있다.

1. 클래스가 final 이면 클래스 아래에 어떤 구현이 있는지 알 수 있다.
2. open 클래스는 서브 클래스를 대신 제공하기 때문에 더 자유롭게 구현이 있는지 확인할 수 있다.

### 4.27.4 인터페이스

코틀린 표준 라이브러리는 거의 대부분 인터페이스로 표현된다.

- listOf함수는 List 인터페이스를 리턴한다. listOf는 팩토리 메소드이다.
- 컬렉션 처리 함수는 Iterable 또는 Collection 의 확장 함수로, List, Map 인터페이스를 리턴한다.
- 프로퍼티 위임은 ReadOnlyProperty, ReadWriteProperty 인터페이스 뒤에 숨겨진다. 실제 클래스는 보통 private이고, 함수 lazy는 Lazy 인터페이스를 리턴한다.

라이브러리를 만드는 사람은 내부 클래스의 가시성을 제한하고 인터페이스를 노출해서 사용자가 추상화된 것에만 의존하게 만들어 커플링을 줄인다.

또, 코틀린은 멀티플랫폼 언어라 어떤 환경이냐에 따라 구현이 다른 리스트를 반환하기 때문에 인터페이스를 반환하는 것도 있다.

또, 인터페이스 페이킹이 클래스 모킹보다 간단해서 별도의 모킹 라이브러리를 사용하지 않아도 된다.

마지막으로 선언과 사용이 분리되어 있어 실제 클래스를 자유롭게 변경할 수 있다. 단, 인터페이스를 먼저 변경해서 구현하고 있는 모든 클래스도 변경해주어야 한다.

```kotlin
interface MessageDisplay {
	fun show(message: String, duration: MessageLength = LONG)
}

class ToastDisplay(val context: Context): MessageDisplay {
	override fun show(message: String, duration: MessageLength) {~구현}
}

enum class MessageLength{ SHORT, LONG}
```

### 4.27.5 ID 만들기(nextId)

고유 아이디를 만들어야 하는 경우가 있다.

```kotlin
var nextId: Int = 0
val newId = nextId++
```

단, 이런 경우에 문제가 있다.

1. 아이디가 무조건 0부터 시작한다.
2. 코드가 thread-safe하지 않다.

```kotlin
private var nextId: Int = 0
fun getNextId() = nextId++

val newId = getNextId()
```

먼저, 이렇게 해서 변경으로부터 코드를 보호한다.(직접 접근이 아니라 함수를 통해서만 변경하게끔 해서 여기저기서 무분별하게 사용하는 것을 막음 → 음 근데.. 이렇게 하면 thread-safe 해져(?)

아이디의 타입을 변경해야할 수도 있다. 그렇다면 아래와 같이 클래스를 사용하면 쉽게 변경할 수 있다.

```kotlin
data class Id(private val id: Int) 
private var nextId: Int = 0
fun getNextId(): Id = Id(nextId++)
```

### 4.27.6 추상화가 주는 자유

추상화 방법은,

1. 상수로 추출
2. 동작을 함수로 래핑
3. 함수를 클래스로 래핑
4. 인터페이스 뒤에 클래스를 숨김
5. 보편적인 객체를 특수한 객체로 래핑

이 있고, 활용 도구는,

1. 제네릭 타입 파라미터 사용
2. 내부 클래스 추출
3. 팩토리 함수로만 객체를 생성할 수 있게끔 한다던지 해서 생성을 제한

### 4.27.7 추상화의 문제

추상화도 비용이 발생한다. 원래 10줄도 안되는 코드도 61개의 클래스와 26개의 인터페이스로 분리할수도 있다. 이러면 코드를 이해하는게 어려워진다.

### 4.27.8 어떻게 균형을 맞춰야 할까?

추상화는 자유를 주지만 코드가 어떻게 돌아가는지 이해하기 어렵게 만든다.

- 팀의 크기
- 팀의 경험
- 프로젝트 크기
- 특징 세트(?)
- 도메인 지식

등의 요소에 따라 균형을 찾아야 한다.

- 많은 개발자가 참여하면 추상화를 하고 최대한 모듈과 부분을 분리하는 것이 좋다.
- 의존성 주입 프레임워크를 사용하면 클래스는 한번만 정의하면 돼서 생성이 얼마나 복잡한지 신경쓰지 않아도 된다.
- 테스트를 하거나 다른 앱을 기반으로 새로운 앱을 만드는 경우엔 추상화를 사용하는 것이 좋다.
- 프로젝트가 작고 실험적이라면 추상화를 하지 않아도 된다.

항상 무언가 변화할 수 있다고 생각하는 것이 좋다.

### 4.27.9 정리

추상화는 코드를 변경할 때 좋지만 사용하는 것은 어렵고, 이해하기도 어렵다. 균형을 찾는게 중요하다.
