컴퓨터는 굉장히 복잡하지만 여러 계층에 다양한 요소로 분할되어 있기 때문에 쉽게 사용할 수 있는 것이다. 

가장 낮은 추상화 계층인 하드웨어부터 시작해서 → 프로세서 제어 명령 → 0과 1을 읽는 어셈블리 → 컴파일러 → 프로그래밍 언어가 되어 우리가 쉽게 개발할 수 있게 되었다.

계층이 잘 분리되면 아래 계층이 이미 완성되어 있기 때문에 해당 계층만 생각하면 돼서 다른 쪽을 알지 못해도 된다는 장점이 있다.

### 26.1 추상화 레벨

높은 레벨로 갈 수록 물리 장치로부터 멀어지고, 세부적인 내용들을 고려할 필요가 없다. 

단순하지만 제어력을 잃고 메모리 사용을 최적화하는 것이 힘들다.

### 26.2 추상화 레벨 통일

컴퓨터처럼 코드도 추상화를 계층처럼 만들어 사용할 수 있다. 그 기본적인 도구가 바로 함수이다. 함수도 높은 레벨과 낮은 레벨을 구분해서 사용해야 한다는 원칙이 있다. 바로, **추상화 레벨 통일(Single Level Of Abstraction, SLA) 원칙**이라고 한다.

```kotlin
class CoffeMachine {
	fun makeCoffee() {
		//수백 개의 변수를 선언
		//복잡한 로직 처리
		//낮은 수준의 최적화 다량 처리
	}
}
```

이런 식으로 작성하면 함수가 수백 줄이 될 수 있고 세부적인 내용들을 이해하기 어렵고 요구사항 변경으로 인한 수정도 어렵다.

```kotlin
class CoffeMachine {
	fun makeCoffee() {
		boilWater()
		brewCoffee()
		pourCoffee()
		pourMilk()
	}

	private fun boilWater()~
	private fun brewCoffee()~
	private fun pourCoffee()~
	private fun pourMilk()~
}
```

간단히 추상화를 추출해서 가독성을 크게 향상시켰다. 

함수는 작아야하며, 최소한의 책임만 가져야 한다. 함수를 추출하면 재사용과 테스트가 쉬워진다.

### 26.3 프로그램 아키텍처의 추상 레벨

추상화 계층이라는 개념은 함수보다 높은 레벨에서도 적용할 수 있다. 서브 시스템의 세부 사항을 숨겨서 상호 운영성과 플랫폼 독립성을 얻는다.

번호가 높아질 수록 높음

1. 운영 체제 연산과 머신 명령
2. 프로그램 언어 구조와 도구 
3. 낮은 레벨 구현 구조
4. 낮은 레벨 문제 중심
5. 높은 레벨 문제 중심 

이는 모듈 시스템을 설계할 때도 중요하다. 모듈을 분리해서 계층 고유의 요소를 숨긴다. 비즈니스 로직을 나타내는 부분이 높은 레벨이고 입출력은 낮은 레벨의 모듈이다.

계층이 잘 분리되면 어떤 계층 위치에서 보아도 일관적인 관점을 얻을 수 있다.

### 26.4 정리

추상화 계층을 만들면 knowledge를 체계화하고, 서브시스템의 세부사항을 숨겨서 상호 운영성과 플랫폼 독립성을 얻게 한다. 

각각의 레이어가 너무 커지는 것은 좋지 않고 작고 최소한의 책임만 갖는 함수가 이해하기 쉽다.

추상화 레벨은 구체적인 동작, 프로세서, 입출력과 가까울수록 낮은 레벨이라고 하고 낮은 계층에서는 높은 계층에서 사용하는 요소(API)를 만든다.
