# 아이템 45. 불필요한 객체 생성을 피하라

객체 생성에는 비용이 발생한다. 따라서 JVM은 동일한 문자열을 처리하는 코드가 여러 개가 있다면 기존 문자열을 재사용하기도 한다.

래핑된 기본 자료형도 재사용된다. ===로 비교하면 true가 뜨는 것을 확인할 수 있다. Int의 경우 -128~127 범위를 캐시해둔다. 

nullable 타입은 int 대신 Integer 를 강제로 사용하게 된다. 기본 자료형은 null일 수 없기 때문이다.

## 객체 생성 비용은 항상 클까?

비용 발생 

- 객체는 더 많은 용량을 차지한다 현대 64비트 JDK 에서 객체는 8의 배수만큼의 공간을 차지하고, 객체에 대한 레퍼런스 공간을 더 차지한다. 반드시 있어야 하는 헤더는 12바이트이다. 일반적으로 레퍼런스는 -Xms32G에서 4바이트고, 이후부터는 8바이트이다.  따라서 기본 자료형 int는 4바이트이지만 Integer는 16바이트이고, 레퍼런스가 더해지면 24바이트라서 5배 이상의 공간을 차지하게 된다.
- 요소가 캡슐화되어 있다면 접근에 추가적인 함수 호출이 필요한데, 빨라서 비용이 크지 않지만 쌓이면 커질 수 있다.
- 생성된 객체의 비용 발생

## 객체 선언

객체를 싱글톤으로 만들어주고 사용하면 재사용할 수 있다. 

제네릭 타입의 리스트를 재사용할 수 없기 때문에(타입이 구체화되는 곳이 다 다르기 때문에) Nothing 을 사용하면, Nothing은 모든 타입의 서브타입이기 때문에 재사용할 수 있다.

이는 immutable sealed 클래스를 정의할 때 자주 사용된다. mutable은 캐시하지 않는다는 규칙이 있기 때문에 좋지 않다.

## 캐시를 활용하는 팩토리 함수

팩토리 함수는 캐시를 가질 수 있어서 같은 객체를 리턴하게 할 수 있다. 

```kotlin
fun <T> List<T> emptyList() {
	return EMPTY_LIST;
}
```

모든 순수 함수는 캐싱을 활용할 수 있고, 이를 메모이제이션이라고 한다.

단, 저장해야하기 때문에 더 많은 메모리를 사용한다. SoftReference를 사용하면 자동으로 메모리를 해제해준다. (WeakReference와 다른 개념)

- WeakReference: GC가 clean하는 것을 막지 않는다.
- SoftReference: 메모리가 부족해서 추가로 필요한 경우에만 수행한다.

## 무거운 객체를 외부 스코프로 보내기

```kotlin
fun <T: Comarable<T>> Iterable<T>.countMax(): Int{
	val max = this.max()
	return count{ it==max}
}
```

## 지연 초기화

무거운 클래스를 지연하면 생성하는 과정을 가볍게 만들 수 있다. 하지만 첫 번째 호출 때 응답 시간이 굉장히 걸릴 수 있다. 일반적으로 백엔드는 전체적인 실행 시간은 중요하지 않기 때문에 상황에 맞게 사용하는 것이 좋다.

## 기본 자료형 사용하기

랩한 자료형을 사용하는 경우

1. nullable 타입
2. 타입을 제네릭으로 사용할 때 

숫자 연산 정도는 성능적으로 큰 차이가 없어서 큰 ㅋ컬렉션을 처리할 때 차이를 확인할 수 있다. 

```kotlin
fun Iterable<Int>.maxOrNull(): Int? {
	var max: Int? = null
	for(i in this) {
		max = if(i > (max ?: Int.MIN_VALUE)) i else max
	}
	return max
}
```

단점

1. 엘비스 연산자
2. nullable한 값을 사용해서 int 가 아니라 Integer로 연산

따라서 while을 사용해서 단점을 극복할 수 있다.

이정도의 최적화가 중요하지 않을 수 있지만 라이브러리를 만드는 경우에는 성능이 중요할 수 있다.
