# 아이템19. knowledge를 반복하여 사용하지 말라

```
<<실용주의 프로그래머>> 에서 DRY원칙에서 말하는 knowledg는 지식이 아니라 '의도적인 정보'를 나타낸다.

DRY원칙 (Don't Repeat Yourself)
모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다.
(Every piece of knowledge must have a single, unambigous, authoritative representation within a system)

= WET 안티패턴(We Enjoy Typing, Waste Everyone's Time Or Write Everything Twice)
개발자는 타이핑하는 걸 좋아해서 많은 사람의 시간을 낭비하게 만들거나 같은 코드를 두 번씩 작성한다 라고 비꼬는 것

= SSOT(Signle Source Of Truth)
```

‘프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다.’ 라고 표현할 수 있다. 

## 19.1 Knowledge

= 넓은 의미의 ‘의도적인 정보’

예를 들어서 상속을 하면서도 특정 메소드를 오버라이드하지 않게 해서 슈퍼 클래스와 동일한 동작을 하도록 만드는 것 처럼, 정의한 모든 것이 knowledge 이다. 알고리즘의 동작 방식, UI 형태, 우리가 원하는 결과 등이 모두 ‘의도적인 정보'라고 할 수 있고, 도구, 가상머신, 다른 프로그램들에서 직접 혹은 간접적으로 이해할 수 있는 정보이다.

중요한 knowledge 는,

1. 로직 : 프로그램이 어떤 식으로 동작하고 보이는지,
2. 공통 알고리즘: 원하는 동작을 하기 위한 알고리즘

크게 2가지로 볼 수 있다. 둘의 큰 차이점은 시간에 따른 변화이다. 비즈니스 로직은 시간이 지나면서 계속 변하지만, 공통 알고리즘은 한 번 정의된 후에는 크게 변하지 않는다.

## 19.2 로직 - 모든 것은 변화한다.

모든 프로그램은 변화하는데, 변화할 때 가장 큰 적은 knowledge가 반복되는 것이다. 여러 부분에 반복되어 있는 코드를 변경하려면 모두 찾아서 수정해야하는데 실수가 발생할 수 있다. knowledge의 반복은 확장성(scalable)을 막고, 쉽게 깨지게(fragile) 만든다. 따라서 ORM, DAO 와 같은 기술을 활용해 반복을 줄일 수 있다.

## 19.3 언제 코드를 반복해도 될까?

반대로 knowledge의 반복을 줄이면 안되는 경우도 있다. 얼핏보면 knowledge의 반복처럼 보이지만, 실질적으로 다른 knowledge를 나타내는 경우이다.

‘함께 변경될 가능성이 있는가?’에 대한 질문으로 어느 정도 결정할 수 있다. 혹은 비즈니스 규칙이 다른 곳(source)에서 왔다면 독립적으로 변경될 가능성이 높다. 

## 19.4 단일 책임 원칙

코드를 추출해도 되는지를, SOLID 원칙 중 하나인 단일 책임 원칙으로 확인해볼 수도 있다. **단일 책임 원칙**이란, ‘클래스를 변경하는 이유는 단 한가지여야 한다' 라는 의미이다. <<클린 아키텍쳐>> 에서는 ‘두 액터가 같은 클래스를 변경하는 일은 없어야 한다'라고 표현했다. 

예를 들어서 어떤 대학에서 Student라는 클래스가 있는데 장학금 관련된 부서(1), 인증과 관련된 부서(2)에서 모두 사용되는 경우가 있다. 장학금을 받을 수 있는 포인트를 갖는 qualifiesForScholarship 이라는 필드를 (1)에서 추가했고, 인증을 통과했는지를 의미하는 isPassing이라는 필드를 (2)에서 추가했다. 

이 두 프로퍼티는 학생의 이 전 학기 성적을 기반으로 계산되기 때문에 한꺼번에 계산하는 함수를 만들었는데, 갑자기 ‘덜 중요한 과목은 장학금 포인트를 줄이라’고 요구사항이 변경됐다. 그렇다면 같은 함수에서 처리했단 isPassing 필드도 영향을 받게 된다.

이러한 문제를 방지하기 위해 처음부터 책임에 따라서 다른 클래스로 구분해서 만들어야 한다. 예를 들어서 StudentIsPassingValidator, StudentQualifiesForScholarshipValidator 와 같이 말이다. 아니면 확장함수를 이용해 각각의 부서가 관리하는 서로 다른 모듈 파일에 배치할 수도 있다.

1. 두 부서에서 모두 사용하는 일반적인 public 함수로 헬퍼 함수를 만든다. 이는 함부로 수정해서는 안된다.
2. 헬퍼 함수를 각각의 부서 모듈에 따라 2개를 만든다.

따라서,

1. 서로 다른 곳에서 사용하는 knowledge는 독립적으로 변경할 가능성이 있기 때문에 완전히 다른 Knowledge로 취급하는 것이 좋다.
2. 다른 knowledge는 분리해서 재사용이 아예 되지 않도록 한다.
