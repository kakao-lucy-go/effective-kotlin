# 아이템20.일반적인 알고리즘을 반복해서 구현하지 말라

특정 프로젝트에 국한된 것이 아니라 수학적 연산같이 별도의 모듈, 라이브러리로 분리할 수 있는 알고리즘을 반복해서 구현하지 않는다.

stdlib의 coerceIn과 같이 이미 구현된 알고리즘도 있고, 재사용하는 것이 좋다.

1. 코드 작성 속도가 빨라진다.
2. 한 번 보고 나면 구현을 따로 읽지 않아도 함수의 이름등만 보고도 무엇을 하는지 알 수 있다.
3. 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있다. 
4. 한 번 최적화를 하면 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있다.

## 20.1 표준 라이브러리 살펴보기

대부분 알고리즘은 표준 라이브러리인 stdlib에 구현되어 있다. 이를 사용하면 최적화된 알고리즘을 사용할 수 있다.

## 20.2 나만의 유틸리티 구현하기

상황에 따라서는 표준 라이브러리에 없는 알고리즘을 구현해야할 수도 있는데, 널리 알려진 수학적 개념이라면 범용 유틸리티 함수로 정의하는 것이 좋다.

```kotlin
fun Iterable<Int>.product() = fold(1) {acc, i -> acc * i}
```

많이 사용되는 알고리즘을 추출하는 방법은, 

1. 톱레벨 함수 
2. 프로퍼티 위임, 클래스 

등이 있다.

확장 함수를 사용하는 것은 위의 2가지 보다 다음과 같은 장점이 있다.

1. 함수는 상태를 갖지 않기 때문에, 행위를 나타내기에 좋다. side-effect가 없는 경우에는 더 좋다.
2. 톱레벨 함수와 비교해서, 확장함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있어 좋다.
3. 수정할 객체를 아규먼트로 전달받아 사용하는 것 보다 확장 리시버로 사용하는 것이 가독성 측면에서 좋다.
4. 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때 자동 완성 기능 등으로 제안되기 때문에 쉽게 찾을 수 있다.
