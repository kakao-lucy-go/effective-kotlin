# 아이템 35. 복잡한 객체를 생성하기 위한 DSL을 정의하라

DSL(Domain Specific Language)은 복잡한 객체, 계층적 자료 구조를 갖는 객체들을 정의할 때 유용하다. 만드는게 좀 힘들지만 한 번 만들면 보일러플레이트를 숨길 수 있다.

### 5.35.1 사용자 정의 DSL 만들기

함수 타입: 함수로 사용할 수 있는 객체

- () → Unit - 아규먼트 없이 Unit을 리턴
- (Int) → Unit - Int를 아규먼트로 하고 Unit 리턴
- (Int) → () → Unit: Int를 아규먼트로 받고 다른 함수를 리턴, 이때 다른 함수는 아규먼트로 아무것도 받지 않고 Unit 리턴

함수 타입을 만드는 방법

- 람다 표현식 : 익명 함수를 짧게 작성
- 익명 함수 : 이름을 갖고 있지 않은 함수
- 함수 레퍼런스

리시버를 가진 함수 타입: 점 기호로 구분되어 파라미터 앞에 리시버 타입이 추가됨. 

호출 방법:

- 일반적인 객체처럼 Invoke 메소드 사용
- 확장 함수가 아닌 함수처럼 사용

```json
val myPlus: Int.(Int) -> Int = {this + it} //리시버를 가진 람다 표현식
myPlus.invoke(1,2)
myPlus(1,2)
1.myPlus(2)
```

리시버를 가진 함수 타입의 가장 중요한 특징은 this의 참조 대상을 변경할 수 있다는 것이다. this는 apply 함수에서 리시버 객체의 메소드, 프로퍼티를 간단하게 참조할 수 있게 해준다.

리시버를 가진 함수 타입은 DSL을 구성하는 가장 기본적인 블록이다.

이제 각각의 단계에서 빌더를 만들고 초기화하면 된다.  apply로 코드를 짧게 만들수도 있다.

### 5.35.2 언제 사용해야 할까?

DSL에 익숙하지 않은 경우 유지보수가 어렵다.

- 복잡한 자료 구조
- 계층적 구조
- 거대한 양의 데이터

를 표현하는 경우에 유용하다. 많이 사용되는 구조의 반복을 제거할 수 있게 해준다.

### 5.35.3 정리

언어 내부에서 사용할 수 있는 특별한 언어이다. (근데.. 딱히 특별한 언어라는 생각은 안들고, 확장 함수, 빌더패턴을 사용해서 반복되는 코드를 줄여주는 기능으로만 보임.. )
